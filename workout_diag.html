<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Horizon Trainer V19 (Full UUID)</title>
    <style>
        :root { --bg: #0f172a; --surface: #1e293b; --primary: #3b82f6; --text: #f8fafc; }
        body { font-family: -apple-system, sans-serif; background: var(--bg); color: var(--text); padding: 20px; display: flex; flex-direction: column; align-items: center; }
        
        button {
            background: var(--primary); color: white; border: none; padding: 25px; 
            font-size: 22px; border-radius: 12px; width: 100%; max-width: 400px;
            margin-bottom: 20px; font-weight: bold; cursor: pointer;
        }
        button:active { opacity: 0.8; }

        /* 日誌區 */
        #console-log {
            width: 100%; max-width: 400px; height: 200px;
            background: #332b00; border: 2px solid #facc15; color: #facc15;
            padding: 10px; font-family: monospace; font-size: 12px;
            overflow-y: scroll; border-radius: 8px; box-sizing: border-box;
        }

        /* 儀表板簡化版 */
        .dash { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; width: 100%; max-width: 400px; margin-bottom: 20px; }
        .box { background: var(--surface); padding: 15px; border-radius: 10px; text-align: center; }
        .val { font-size: 32px; font-weight: bold; }
        .lbl { font-size: 12px; color: #aaa; }
        
        .controls { width: 100%; max-width: 400px; display: flex; gap: 10px; }
        .ctrl-btn { flex: 1; padding: 15px; background: #334155; color: white; border:none; border-radius: 8px; font-size: 18px; }
    </style>
</head>
<body>

    <h2>V19 全碼修復版</h2>

    <button id="mainBtn">1. 掃描並連線</button>

    <div id="console-log">等待操作...</div>

    <div class="dash">
        <div class="box"><div id="rpm" class="val">0</div><div class="lbl">RPM</div></div>
        <div class="box"><div id="res" class="val">1</div><div class="lbl">阻力</div></div>
    </div>

    <div class="controls">
        <button class="ctrl-btn" onclick="setRes(-1)">- 阻力</button>
        <button class="ctrl-btn" onclick="setRes(1)">+ 阻力</button>
    </div>

<script>
    // *** 關鍵修正：使用 128-bit 完整 UUID ***
    // iOS WebKit 對短碼支援極差，必須用全碼
    const FTMS_UUID = "00001826-0000-1000-8000-00805f9b34fb";
    const DATA_UUID = "00002ad2-0000-1000-8000-00805f9b34fb";
    const CTRL_UUID = "00002ad9-0000-1000-8000-00805f9b34fb";

    let controlChar;
    let currentRes = 1;

    const logBox = document.getElementById('console-log');
    const rpmDisp = document.getElementById('rpm');
    const resDisp = document.getElementById('res');

    // 日誌工具
    function log(msg) {
        const t = new Date().toLocaleTimeString().split(' ')[0];
        logBox.innerHTML += `<div>[${t}] ${msg}</div>`;
        logBox.scrollTop = logBox.scrollHeight;
    }

    // 全域錯誤捕捉
    window.onerror = function(msg) {
        log("JS ERROR: " + msg);
    };

    // 按鈕事件綁定 (使用 addEventListener 更保險)
    document.getElementById('mainBtn').addEventListener('click', async () => {
        log("按鈕已點擊，開始流程..."); // 第一步確認按鈕有反應

        if (!navigator.bluetooth) {
            log("錯誤：找不到藍牙 API (請用 Bluefy)");
            return;
        }

        try {
            log("呼叫 requestDevice...");
            
            // 請求裝置 (使用 acceptAllDevices + 完整 UUID)
            const device = await navigator.bluetooth.requestDevice({
                acceptAllDevices: true,
                optionalServices: [FTMS_UUID] // 這裡傳入的是長字串
            });

            log(`選取裝置: ${device.name}`);
            log("正在連線 GATT...");
            
            const server = await device.gatt.connect();
            log("GATT 連線成功！");

            log("取得服務 (Service)...");
            const service = await server.getPrimaryService(FTMS_UUID);
            
            log("取得特徵值 (Characteristics)...");
            controlChar = await service.getCharacteristic(CTRL_UUID);
            const dataChar = await service.getCharacteristic(DATA_UUID);
            
            log("啟動通知 (Notifications)...");
            await dataChar.startNotifications();
            dataChar.addEventListener('characteristicvaluechanged', parseData);

            // 解鎖飛輪
            log("發送解鎖指令...");
            await sendHex(0x00);
            await sendHex(0x07);

            log(">>> 連線完成！ <<<");
            document.getElementById('mainBtn').innerText = "已連線";
            document.getElementById('mainBtn').style.background = "#10b981";

            // 心跳包
            setInterval(() => sendHex(0x07), 30000);

        } catch (e) {
            log("失敗: " + e);
            // 如果是物件，嘗試印出內容
            if (typeof e === 'object') log(JSON.stringify(e));
        }
    });

    // 數據解析
    function parseData(event) {
        const val = event.target.value;
        const flags = val.getUint16(0, true);
        let offset = 2;

        // Speed (Bit 0)
        if ((flags & 0x01) === 0) offset += 2;
        // Avg Speed (Bit 1)
        if (flags & 0x02) offset += 2;
        // Cadence (Bit 2)
        if (flags & 0x04) {
            const rpm = val.getUint16(offset, true) * 0.5;
            rpmDisp.innerText = Math.floor(rpm);
            offset += 2;
        }
        // Skip others to find Resistance
        if (flags & 0x08) offset += 2;
        if (flags & 0x10) offset += 3;
        
        // Resistance (Bit 5)
        if (flags & 0x20) {
            const r = val.getInt16(offset, true);
            if (r > 0) {
                currentRes = r;
                resDisp.innerText = r;
            }
        }
    }

    // 阻力控制
    async function setRes(delta) {
        if (!controlChar) {
            log("尚未連線");
            return;
        }
        currentRes += delta;
        if (currentRes < 1) currentRes = 1;
        if (currentRes > 32) currentRes = 32;
        resDisp.innerText = currentRes;

        const target = currentRes * 10;
        const buffer = new ArrayBuffer(3);
        const view = new DataView(buffer);
        view.setUint8(0, 0x04);
        view.setUint16(1, target, true); // Little Endian
        
        log(`設定阻力: ${currentRes}`);
        await controlChar.writeValue(buffer).catch(e => log("寫入錯誤:"+e));
    }

    async function sendHex(byte) {
        if(controlChar) await controlChar.writeValue(new Uint8Array([byte])).catch(()=>{});
    }

</script>
</body>
</html>
